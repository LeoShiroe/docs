"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[675],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>p});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),d=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},w=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=d(a),w=n,p=h["".concat(s,".").concat(w)]||h[w]||u[w]||i;return a?r.createElement(p,o(o({ref:t},c),{},{components:a})):r.createElement(p,o({ref:t},c))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=w;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:n,o[1]=l;for(var d=2;d<i;d++)o[d]=a[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}w.displayName="MDXCreateElement"},5142:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var r=a(7462),n=(a(7294),a(3905));const i={id:"reward-mechanism",title:"Reward Mechanism",sidebar_label:"Reward Mechanism",slug:"/reward-mechanism"},o=void 0,l={unversionedId:"project/reward-mechanism",id:"project/reward-mechanism",title:"Reward Mechanism",description:"Introduction",source:"@site/docs/project/reward-mechanism.mdx",sourceDirName:"project",slug:"/reward-mechanism",permalink:"/reward-mechanism",draft:!1,editUrl:"https://github.com/WeatherXM/docs/blob/main/docs/project/reward-mechanism.mdx",tags:[],version:"current",frontMatter:{id:"reward-mechanism",title:"Reward Mechanism",sidebar_label:"Reward Mechanism",slug:"/reward-mechanism"},sidebar:"docs",previous:{title:"Tokenomics",permalink:"/tokenomics"},next:{title:"Quality of Data (QoD)",permalink:"/project/quality-of-data"}},s={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Reward mechanism v2.0",id:"reward-mechanism-v20",level:2},{value:"High-level flow",id:"high-level-flow",level:3},{value:"Daily Rewards Calculation Process",id:"daily-rewards-calculation-process",level:3},{value:"1. Base Rewards calculation",id:"1-base-rewards-calculation",level:4},{value:"2. Business Boost rewards calculation",id:"2-business-boost-rewards-calculation",level:4},{value:"3. Cumulative Rewards Calculation",id:"3-cumulative-rewards-calculation",level:4},{value:"4. Merkle Tree Creation",id:"4-merkle-tree-creation",level:4},{value:"Pseudocode",id:"pseudocode",level:4},{value:"Withdrawing Rewards",id:"withdrawing-rewards",level:3},{value:"Smart Contracts and Rewarding Mechanism",id:"smart-contracts-and-rewarding-mechanism",level:3},{value:"Reward mechanism v1.5",id:"reward-mechanism-v15",level:2},{value:"Daily Rewards Calculation Process",id:"daily-rewards-calculation-process-1",level:3},{value:"1. Actual Rewards calculation",id:"1-actual-rewards-calculation",level:4},{value:"Reward mechanism v1.0",id:"reward-mechanism-v10",level:2},{value:"How Often does the Reward Algorithm run?",id:"how-often-does-the-reward-algorithm-run",level:3},{value:"Calculation of the Reward Score",id:"calculation-of-the-reward-score",level:3},{value:"Explanation",id:"explanation",level:3},{value:"Reward Distribution Mechanism",id:"reward-distribution-mechanism",level:3},{value:"Links",id:"links",level:2}],c={toc:d};function h(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"introduction"},"Introduction"),(0,n.kt)("admonition",{type:"important"},(0,n.kt)("p",{parentName:"admonition"},"The Reward Mechanism is currently at ",(0,n.kt)("strong",{parentName:"p"},"version 2.0"),". This page serves as both an informational resource about its current status and a how we got here.")),(0,n.kt)("p",null,"The Reward Mechanism has undergone a progressive evolution across its versions, each iteration introducing refinements to bolster fairness and transparency in the rewarding process for weather station owners contributing data to the network."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"In its inaugural version (v1.0), the mechanism primarily gauged a station's eligibility based on its connection status to the network and the requirement for active wallet ownership, resulting in a somewhat simplistic reward calculation. In this version, the users received in a daily basis the WXM testnet rewards at their wallets."),(0,n.kt)("li",{parentName:"ul"},"The subsequent release, v1.5, marked a significant advancement by expanding the criteria for reward eligibility. This version incorporated additional factors such as the Quality-of-Data (QoD), Proof-of-Location (PoL), Hardware-Classes (HC) and the Cell-Capacity (CP).\nThese additions contributed to a more sophisticated and equitable system, ensuring that rewards were allocated based on data quality, accurate location proof, and user engagement. "),(0,n.kt)("li",{parentName:"ul"},"The third iteration, v2.0, will introduce substantial enhancements, including the incorporation of Business Boost rewards and the implementation of a Merkle Tree structure for transparent reward distribution. The utilization of Merkle Tree will lead users in withdrawing, whenever they choose to do, their rewards from the smart contract.\nBusiness Boost rewards added an additional layer of fairness by incorporating predefined criteria, while the Merkle Tree structure facilitated a verifiable and transparent mechanism for users to validate the distribution of their rewards.\nThis evolutionary trajectory underscores a commitment to refining the Reward Mechanism, making it more inclusive, nuanced, and transparent to build trust among weather station owners participating in the network.")),(0,n.kt)("h2",{id:"reward-mechanism-v20"},"Reward mechanism v2.0"),(0,n.kt)("p",null,"The Reward Mechanism v2.0 is the latest iteration of the rewarding mechanism. It is a significant advancement over the previous version, v1.5, and it introduces the following enhancements:"),(0,n.kt)("h3",{id:"high-level-flow"},"High-level flow"),(0,n.kt)("p",null,"Every day, the reward algorithm assesses the performance of all weather stations, calculates additional rewards originating from Business Boost use cases, bundles them together with the users' wallet addresses, and creates a Merkle Tree, the root hash of which is submitted to the RewardPool."),(0,n.kt)("p",null,"Users have the option to withdraw their rewards either by accessing the Merkle proof on the WeatherXM Platform or by retrieving the Merkle proof from IPFS and programmatically initiating the procedure. At any given time users have the flexibility to withdraw any amount they desire, provided it does not exceed the total allocated amount."),(0,n.kt)("h3",{id:"daily-rewards-calculation-process"},"Daily Rewards Calculation Process"),(0,n.kt)("p",null,"The Reward Mechanism calculates the amount of tokens that will be allocated to users by completing the following phases:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Base Rewards calculation"),(0,n.kt)("li",{parentName:"ol"},"Business Boost Rewards calculation"),(0,n.kt)("li",{parentName:"ol"},"Cumulative Rewards calculation"),(0,n.kt)("li",{parentName:"ol"},"Merkle Tree creation")),(0,n.kt)("p",null,"Let's take a deep dive into each one of these."),(0,n.kt)("h4",{id:"1-base-rewards-calculation"},"1. Base Rewards calculation"),(0,n.kt)("p",null,"Base rewards calculation follows the ",(0,n.kt)("strong",{parentName:"p"},"Actual Rewards Calculation")," already introduced in ",(0,n.kt)("strong",{parentName:"p"},"Reward Mechanism v1.5"),"."),(0,n.kt)("h4",{id:"2-business-boost-rewards-calculation"},"2. Business Boost rewards calculation"),(0,n.kt)("p",null,"The business boost use cases reward specific devices with a predefined amount of tokens from the Business Development Pool for a period of time. In this phase, all business boost rewards are calculated for each active business boost use case and they are assigned to the eligible devices. The business boost rewards are calculated using the following formula per active business boost use case:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"business_boost_reward = (business_boost_total_rewards / business_boost_duration) / number_of_business_boost_stations\n")),(0,n.kt)("h4",{id:"3-cumulative-rewards-calculation"},"3. Cumulative Rewards Calculation"),(0,n.kt)("p",null,"In the third phase of the rewarding mechanism, the cumulative rewards per user are calculated. The cumulative rewards are the sum of all base and business boost rewards that each user's weather station  owns."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"cumulative_rewards_per_customer = sum(base_reward[i] + business_boost_reward[i]), i = 1..n where n = total number of devices per user\n")),(0,n.kt)("h4",{id:"4-merkle-tree-creation"},"4. Merkle Tree Creation"),(0,n.kt)("p",null,"In the final phase, the cumulative rewards coupled with the users' wallet addresses are utilized to create the Merkle tree. The root hash of the Merkle tree is submitted daily in the smart contract to enable $WXM rewards withdrawal by the users."),(0,n.kt)("h4",{id:"pseudocode"},"Pseudocode"),(0,n.kt)("p",null,"To sum up all of the above in pseudocode:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// base reward\nrewardable = {\n  'Helium': {\n    count: 0,\n    weight: 0.9,\n    devices: []\n  },\n  'M5': {\n    count: 0,\n    weight: 1.1,\n    devices: []\n  }\n}\n\nfor cell in cells:\n  cell_devices = []\n  for device in cell:\n    if isEmpty(device.owner.wallet):\n      device.reward_score = 0\n      device.reward_reason = 'NO_WALLET'\n      device.base_reward = 0\n      continue\n    if qod_score < qod_threshold:\n      device.reward_score = 0\n      device.reward_reason = 'QOD_THRESHOLD'\n      device.base_reward = 0\n      continue\n    if pol_score < pol_threshold:\n      device.reward_score = 0\n      device.reward_reason = 'POL_THRESHOLD'\n      device.base_reward = 0\n      continue\n    device.reward_score = reward_algorithm(device.pol_score, device.qod_score)\n    cell_devices.push(device)\n    rewardable[device.hardware_class].count += 1\n    rewardable[device.hardware_class].push(device)\n\n  cell_devices.sort( (x, y):  \n    if x.reward_score == y.reward_score:\n      return x.claimedAt - y.claimedAt\n    return y.reward_score - x.reward_score \n  )\n\n  for (device, i) in cell_devices:\n    device.bb_reward = 0\n    if i >= cell.capacity:\n      device.reward_score = 0\n      device.reward_reason = 'MAX_CAPACITY_REACHED'\n      device.base_reward = 0\n\ntotal_weights = 0\nfor key in rewardable.keys:\n  hc = rewardable[key]\n  total_weights += hc.count * hc.weight \n\nfor key in rewardable.keys:\n  hc = rewardable[key]\n  hc.max_rewards = daily_emission * hc.weight / total_weights \n  for device in hc.devices:\n    device.base_reward = device.reward_score * hc.max_rewards\n\n// business boost\nfor bb in business_boosts:\n  for device in bb.devices:\n    device.bb_reward += bb.daily_reward\n\n// cumulative calculation\nfor user in users:\n  daily_cumulative_rewards = 0\n  for device in user.devices:\n    daily_cumulative_rewards = device.bb_reward + device.base_reward\n  if not user.active_wallet:\n    continue\n  user.wallets[user.active_wallet] = daily_cumulative_rewards\n\n// merkle tree\ntree = []\nfor user in users:\n  for wallet in wallets:\n    tree.push([wallet, user[wallet].cumulative])\n\n\n// blockchain tx\nsubmit(tree.root_hash())\n")),(0,n.kt)("h3",{id:"withdrawing-rewards"},"Withdrawing Rewards"),(0,n.kt)("p",null,"Station owners have the freedom to withdraw their rewards at their discretion, without any time restrictions or other limitations."),(0,n.kt)("p",null,"Each owner may initiate the withdrawal process by signing a transaction using the private key that corresponds to the blockchain address they have connected to their station. A user-friendly front-end that can be used in conjunction with a wallet like Metamask will be provided, but station owners can also interact programmatically with the ",(0,n.kt)("strong",{parentName:"p"},"RewardPool")," smart contract to withdraw their rewards directly."),(0,n.kt)("h3",{id:"smart-contracts-and-rewarding-mechanism"},"Smart Contracts and Rewarding Mechanism"),(0,n.kt)("p",null,"The smart contracts and wallets associated with the rewarding mechanism are the following:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"WeatherXM"),": ERC20 token"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"RewardPool"),": smart contract holding users' allocated $WXM rewards"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"RewardVault"),": smart contract holding the total amount of $WXM rewards to be allocated"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"BusinessDevelopmentPool"),": wallet holding all $WXM leftovers from daily rewards")),(0,n.kt)("p",null,"The lifecycle of rewards from the rewarding mechanism to the users' wallets:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"Reward Mechanism")," calculates all rewards and allocates them to ",(0,n.kt)("strong",{parentName:"li"},"RewardPool")),(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"RewardPool")," holds all allocated rewards"),(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"RewardVault")," funds the ",(0,n.kt)("strong",{parentName:"li"},"RewardPool")," with the daily emission of $WXM"),(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"Business Development Pool")," funds daily the ",(0,n.kt)("strong",{parentName:"li"},"RewardPool")," with the business boost of $WXM"),(0,n.kt)("li",{parentName:"ul"},"The station owners withdraw their rewards programmatically or through the WeatherXM Platform by interacting with the ",(0,n.kt)("strong",{parentName:"li"},"RewardPool"))),(0,n.kt)("h2",{id:"reward-mechanism-v15"},"Reward mechanism v1.5"),(0,n.kt)("p",null,"This section describes the updated ",(0,n.kt)("strong",{parentName:"p"},"Reward Mechanism")," that will be used to allocate $WXM rewards to station owners for contributing weather data to the network. (deprecated)"),(0,n.kt)("admonition",{title:"Important Notes",type:"note"},(0,n.kt)("ul",{parentName:"admonition"},(0,n.kt)("li",{parentName:"ul"},"Connecting a wallet is mandatory to receive rewards. If a user has not connected a wallet, the rewards will be lost."),(0,n.kt)("li",{parentName:"ul"},"Criteria that should be met for a weather station to be rewardable:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"QoD over qod_threshold"),(0,n.kt)("li",{parentName:"ul"},"PoL over pol_threshold"),(0,n.kt)("li",{parentName:"ul"},"weather station\u2019s owner should have an active wallet"))))),(0,n.kt)("h3",{id:"daily-rewards-calculation-process-1"},"Daily Rewards Calculation Process"),(0,n.kt)("p",null,"The Reward Mechanism calculates the amount of tokens that will be distributed to users by completing the following phase:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Actual Rewards calculation")),(0,n.kt)("h4",{id:"1-actual-rewards-calculation"},"1. Actual Rewards calculation"),(0,n.kt)("p",null,"Actual rewards are calculated taking into account the performance of the weather station for the previous day. "),(0,n.kt)("p",null,"This is a short summary of the criteria used:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Proof-of-Location (PoL)"),": An algorithm that evaluates the data about the location of the weather station, its accuracy, consistency, and unison with the location the owner registered on the weather station claiming.\nIt generates a score that denotes confidence about the weather station's location. WeatherXM places great importance on station continuity, necessitating that a station remains stationed at a single location.\nWhen a weather station undergoes relocation, its PoL score reduces to 0 and its seniority in the Cell is reset, aiming to discourage frequent movements and sustain a stable Network. Read more about the ",(0,n.kt)("a",{parentName:"p",href:"/project/proof-of-location"},"Proof of Location (PoL) mechanism"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Quality-of-Data (QoD)"),": An algorithm that evaluates the quality of weather data provided by a weather station. It generates a score that denotes the confidence about the quality of the weather data for each weather station.\nWeatherXM values weather stations that produce meaningful and usable data and the QoD score is an attempt to quantify this metric. The end goal is to encourage weather station owners to do their best to comply with WeatherXM's\nguidelines in order to consistently achieve the best QoD score possible. Read more about the ",(0,n.kt)("a",{parentName:"p",href:"/project/quality-of-data"},"Quality of Data (QoD) mechanism"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Hardware-Class (HC)"),": Each type of approved hardware (weather station) belongs to a specific Hardware Class. Hardware Classes are used to award more tokens to weather stations that have special capabilities,\nincreased sensor accuracy or range, new sensor types, or other capabilities that make them more valuable to the network. For the time being all Hardware Classes are considered equal. Read more about the ",(0,n.kt)("a",{parentName:"p",href:"project/hardware-class"},"Hardware class"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Cell Capacity (CC)"),": Each cell has a pre-defined ",(0,n.kt)("strong",{parentName:"p"},"cell capacity")," that depends on its geospatial characteristics. The cell's ",(0,n.kt)("strong",{parentName:"p"},"capacity")," is the maximum number of stations that may receive rewards in a specific cell.\nIf ",(0,n.kt)("inlineCode",{parentName:"p"},"N")," weather stations are active in a cell with a capacity ",(0,n.kt)("inlineCode",{parentName:"p"},"X")," during a specific day, with ",(0,n.kt)("inlineCode",{parentName:"p"},"N > X"),", only the first ",(0,n.kt)("inlineCode",{parentName:"p"},"N")," stations (ordered first by ",(0,n.kt)("strong",{parentName:"p"},"reward_score"),", then by seniority) will receive rewards. Read more about the ",(0,n.kt)("a",{parentName:"p",href:"project/cell-capacity"},"Cell Capacity (CC)"),"."))),(0,n.kt)("p",null,"We will split the process into 5 distinct steps in an attempt to make everything as clear as possible. "),(0,n.kt)("p",null,"a. The following variables have known values at the start of each day:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"daily_emission"),": the amount of tokens that are available for allocation on the given day"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"weight_per_hardware_class"),": the number denoting how important an HC is compared to all the other HC"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"pol_threshold"),": the number denoting the cutoff threshold for PoL: weather stations with ",(0,n.kt)("inlineCode",{parentName:"li"},"pol_score`` < pol_threshold")," are ",(0,n.kt)("strong",{parentName:"li"},"excluded")," from rewarding"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"qod_threshold"),": the number denoting the cutoff threshold for QoD: weather stations with ",(0,n.kt)("inlineCode",{parentName:"li"},"qod_score < qod_threshold")," are ",(0,n.kt)("strong",{parentName:"li"},"excluded")," from rewarding"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"capacity")," per cell: the maximum number of weather stations that will be rewarded in a cell - the rest are ",(0,n.kt)("strong",{parentName:"li"},"excluded")," from rewarding")),(0,n.kt)("p",null,"b. To calculate the rewardable count of devices per ",(0,n.kt)("strong",{parentName:"p"},"HC"),":"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"we exclude weather stations that are owned by users with no wallet address specified"),(0,n.kt)("li",{parentName:"ul"},"we count the weather stations with ",(0,n.kt)("strong",{parentName:"li"},"qod_score")," and ",(0,n.kt)("strong",{parentName:"li"},"pol_score")," over the respected specified thresholds, ",(0,n.kt)("inlineCode",{parentName:"li"},"qod_threshold"),", ",(0,n.kt)("inlineCode",{parentName:"li"},"pol_threshold")," The number of stations that pass this evaluation are eligible for rewards.")),(0,n.kt)("p",null,"c. To calculate the ",(0,n.kt)("strong",{parentName:"p"},"max_reward_per_hardware_class (MRPHC)"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"total_weights = sum(rewardable_count_per_hardware_class[i] * weight_per_hardware_class[i]), i = 1..n, where n = total number of HC\n")),(0,n.kt)("p",null,"For every HC:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"tokens_per_hardware_class = daily_emission * (rewardable_count_per_hardware_class * weight_per_hardware_class) / total_weights\n\nmax_reward_per_hardware_class = tokens_per_hardware_class / rewardable_count_per_hardware_class\n")),(0,n.kt)("p",null,"d. To calculate the ",(0,n.kt)("strong",{parentName:"p"},"reward_score")," and ",(0,n.kt)("strong",{parentName:"p"},"actual_reward"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"reward_score = pol_score * qod_score\n\nactual_reward = reward_score * max_reward_per_hardware_class\n")),(0,n.kt)("p",null,"e. To identify overcrowded cells and decide which of the weather stations will be excluded from rewarding:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"we iterate over available cells and check whether it is overcrowded"),(0,n.kt)("li",{parentName:"ul"},"in case it is indeed overcrowded, we sort the neighboring weather stations first by ",(0,n.kt)("inlineCode",{parentName:"li"},"reward_score")," and then by seniority (",(0,n.kt)("inlineCode",{parentName:"li"},"claimed_time"),"). Only the ",(0,n.kt)("inlineCode",{parentName:"li"},"N")," first will be rewarded, where ",(0,n.kt)("inlineCode",{parentName:"li"},"N = capacity"))),(0,n.kt)("h2",{id:"reward-mechanism-v10"},"Reward mechanism v1.0"),(0,n.kt)("p",null,"The first iteration of ",(0,n.kt)("strong",{parentName:"p"},"Reward Mechanism")," operates in the following way: only taking into account whether or not a station is connected to the network. (deprecated)"),(0,n.kt)("p",null,"The reward distribution mechanism has two parts:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"The reward algorithm")," which calculates the ",(0,n.kt)("inlineCode",{parentName:"li"},"actual_reward")," for each weather station by evaluating its weather data for the previous day"),(0,n.kt)("li",{parentName:"ul"},"The daily ",(0,n.kt)("strong",{parentName:"li"},"reward distribution")," of rewards to the station owners")),(0,n.kt)("admonition",{title:"Important",type:"note"},(0,n.kt)("p",{parentName:"admonition"},"Connecting a wallet is mandatory to receive rewards. If a user has not connected a wallet, the rewards will be lost.")),(0,n.kt)("h3",{id:"how-often-does-the-reward-algorithm-run"},"How Often does the Reward Algorithm run?"),(0,n.kt)("p",null,"The algorithm runs every day to reward weather stations that were actively sending data to the network for the previous day."),(0,n.kt)("h3",{id:"calculation-of-the-reward-score"},"Calculation of the Reward Score"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"reward_score = array_of_hourly_weather_data / 24")),(0,n.kt)("h3",{id:"explanation"},"Explanation"),(0,n.kt)("p",null,"In the calculation of the ",(0,n.kt)("inlineCode",{parentName:"p"},"reward_score")," step, the algorithm takes into account the weather data for each hour of the previous day for any given weather station."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"If the weather station has successfully sent data for each hour of the previous day, then the algorithm's input is an array of 24 objects,\nwith each object being the station's weather data."),(0,n.kt)("li",{parentName:"ul"},"If the weather station hasn't sent any weather data for 1 or more hours the previous day, then the algorithm's input is an array of (",(0,n.kt)("inlineCode",{parentName:"li"},"24 - X"),") objects,\nwith each object being the station's weather data and ",(0,n.kt)("inlineCode",{parentName:"li"},"X")," being the number of hours that the station hasn't communicated with our system.")),(0,n.kt)("p",null,"That input is then being used by dividing its length by 24 (the maximum hours per day) to get a ",(0,n.kt)("inlineCode",{parentName:"p"},"reward_score")," of ",(0,n.kt)("inlineCode",{parentName:"p"},"0.0")," to ",(0,n.kt)("inlineCode",{parentName:"p"},"1.0"),"."),(0,n.kt)("p",null,"After the calculation of the ",(0,n.kt)("inlineCode",{parentName:"p"},"reward_score")," step, the algorithm takes the ",(0,n.kt)("inlineCode",{parentName:"p"},"reward_score")," for any given weather station in our network, multiplies it with the ",(0,n.kt)("inlineCode",{parentName:"p"},"max_daily_reward")," that the weather\nstation can get, and the result is the amount of WXM tokens that the algorithm distributes to the user who owns that weather station."),(0,n.kt)("p",null,"The formulas which are used to calculate the daily reward per weather station is the following:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"rewardable_count = Count(all_provisioned_weather_stations)\nmax_daily_reward = daily_emission / rewardable_count\nweather_station_reward = reward_score * max_daily_reward\n")),(0,n.kt)("h3",{id:"reward-distribution-mechanism"},"Reward Distribution Mechanism"),(0,n.kt)("p",null,"All daily ",(0,n.kt)("inlineCode",{parentName:"p"},"actual_reward")," per weather station are transferred to the wallet address already set by the user.\nThis is a bulk transfer operations which happens once in a daily schedule and as a result the users get their daily rewards to their wallets.\nDue to blockchain limitations on the number of atomic transfer transactions that may take place with each bulk transfer, as many as needed bulk transfers can be executed for the purpose of everyone getting the daily rewards. "),(0,n.kt)("h2",{id:"links"},"Links"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.weatherxm.com/whitepaper"},"Whitepaper")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"/project/quality-of-data"},"Quality of Data (QoD) mechanism")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"/project/proof-of-location"},"Proof of Location (PoL) mechanism")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"project/cell-capacity"},"Cell Capacity (CC)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"project/hardware-class"},"Hardware class"))))}h.isMDXComponent=!0}}]);