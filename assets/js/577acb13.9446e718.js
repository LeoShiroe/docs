"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[589],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>p});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),d=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},w=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=d(a),w=n,p=h["".concat(l,".").concat(w)]||h[w]||u[w]||i;return a?r.createElement(p,o(o({ref:t},c),{},{components:a})):r.createElement(p,o({ref:t},c))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=w;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:n,o[1]=s;for(var d=2;d<i;d++)o[d]=a[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}w.displayName="MDXCreateElement"},8421:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var r=a(7462),n=(a(7294),a(3905));const i={id:"reward-mechanism-v2",title:"Reward Mechanism v2",sidebar_label:"Reward Mechanism v2",slug:"/reward-mechanism-v2"},o=void 0,s={unversionedId:"project/reward-mechanism-v2",id:"project/reward-mechanism-v2",title:"Reward Mechanism v2",description:"This section describes the updated Reward Mechanism that will be used to allocate $WXM rewards to station owners for contributing weather data to the network.",source:"@site/docs/project/reward-mechanism-v2.mdx",sourceDirName:"project",slug:"/reward-mechanism-v2",permalink:"/reward-mechanism-v2",draft:!1,editUrl:"https://github.com/WeatherXM/docs/blob/main/docs/project/reward-mechanism-v2.mdx",tags:[],version:"current",frontMatter:{id:"reward-mechanism-v2",title:"Reward Mechanism v2",sidebar_label:"Reward Mechanism v2",slug:"/reward-mechanism-v2"},sidebar:"docs",previous:{title:"Reward Mechanism",permalink:"/reward-mechanism"},next:{title:"WXM WS1000 Introduction",permalink:"/wxm-devices/wifi-m5-bundle/wxm-ws1000-introduction"}},l={},d=[{value:"High-level flow",id:"high-level-flow",level:2},{value:"Daily Rewards Calculation Process",id:"daily-rewards-calculation-process",level:2},{value:"1. Base Rewards calculation",id:"1-base-rewards-calculation",level:3},{value:"2. Business Boost rewards calculation",id:"2-business-boost-rewards-calculation",level:3},{value:"3. Cumulative Rewards Calculation",id:"3-cumulative-rewards-calculation",level:3},{value:"4. Merkle Tree Creation",id:"4-merkle-tree-creation",level:3},{value:"Pseudocode",id:"pseudocode",level:3},{value:"Withdrawing Rewards",id:"withdrawing-rewards",level:2},{value:"Smart Contracts and Rewarding Mechanism",id:"smart-contracts-and-rewarding-mechanism",level:2}],c={toc:d};function h(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"This section describes the updated ",(0,n.kt)("strong",{parentName:"p"},"Reward Mechanism")," that will be used to allocate $WXM rewards to station owners for contributing weather data to the network."),(0,n.kt)("h2",{id:"high-level-flow"},"High-level flow"),(0,n.kt)("p",null,"Every day, the reward algorithm assesses the performance of all weather stations, calculates additional rewards originating from Business Boost use cases, bundles them together with the users' wallet addresses, and creates a Merkle Tree, the root hash of which is submitted to the RewardPool."),(0,n.kt)("p",null,"Users have the option to withdraw their rewards either by accessing the Merkle proof on the WeatherXM Platform or by retrieving the Merkle proof from IPFS and programmatically initiating the procedure. At any given time users have the flexibility to withdraw any amount they desire, provided it does not exceed the total allocated amount."),(0,n.kt)("admonition",{title:"Important Notes",type:"note"},(0,n.kt)("ul",{parentName:"admonition"},(0,n.kt)("li",{parentName:"ul"},"Connecting a wallet is mandatory to receive rewards. If a user has not connected a wallet, the rewards will be lost."),(0,n.kt)("li",{parentName:"ul"},"Criteria that should be met for a weather station to be rewardable:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"QoD over qod_threshold"),(0,n.kt)("li",{parentName:"ul"},"PoL over pol_threshold"),(0,n.kt)("li",{parentName:"ul"},"weather station\u2019s owner should have an active wallet"))))),(0,n.kt)("h2",{id:"daily-rewards-calculation-process"},"Daily Rewards Calculation Process"),(0,n.kt)("p",null,"The Reward Mechanism calculates the amount of tokens that will be allocated to users by completing the following phases:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Base Rewards calculation"),(0,n.kt)("li",{parentName:"ol"},"Business Boost Rewards calculation"),(0,n.kt)("li",{parentName:"ol"},"Cumulative Rewards calculation"),(0,n.kt)("li",{parentName:"ol"},"Merkle Tree creation")),(0,n.kt)("p",null,"Let's take a deep dive into each one of these."),(0,n.kt)("h3",{id:"1-base-rewards-calculation"},"1. Base Rewards calculation"),(0,n.kt)("p",null,"Base rewards are calculated taking into account the performance of the weather station for the previous day. "),(0,n.kt)("p",null,"This is a short summary of the criteria used:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Proof-of-Location (PoL)"),": An algorithm that evaluates the data about the location of the weather station, its accuracy, consistency, and unison with the location the owner registered on the weather station claiming. It generates a score that denotes confidence about the weather station's location. WeatherXM places great importance on station continuity, necessitating that a station remains stationed at a single location. When a weather station undergoes relocation, its PoL score reduces to 0 and its seniority in the Cell is reset, aiming to discourage frequent movements and sustain a stable Network.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Quality-of-Data (QoD)"),": An algorithm that evaluates the quality of weather data provided by a weather station. It generates a score that denotes the confidence about the quality of the weather data for each weather station. WeatherXM values weather stations that produce meaningful and usable data and the QoD score is an attempt to quantify this metric. The end goal is to encourage weather station owners to do their best to comply with WeatherXM's guidelines in order to consistently achieve the best QoD score possible.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Hardware-Class (HC)"),": Each type of approved hardware (weather station) belongs to a specific Hardware Class. Hardware Classes are used to award more tokens to weather stations that have special capabilities, increased sensor accuracy or range, new sensor types, or other capabilities that make them more valuable to the network. For the time being all Hardware Classes are considered equal.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Cell Capacity (CC)"),": Each cell has a pre-defined ",(0,n.kt)("strong",{parentName:"p"},"cell capacity")," that depends on its geospatial characteristics. The cell's ",(0,n.kt)("strong",{parentName:"p"},"capacity")," is the maximum number of stations that may receive rewards in a specific cell. If ",(0,n.kt)("inlineCode",{parentName:"p"},"N")," weather stations are active in a cell with a capacity ",(0,n.kt)("inlineCode",{parentName:"p"},"X")," during a specific day, with ",(0,n.kt)("inlineCode",{parentName:"p"},"N > X"),", only the first ",(0,n.kt)("inlineCode",{parentName:"p"},"N")," stations (ordered first by ",(0,n.kt)("strong",{parentName:"p"},"reward_score"),", then by seniority) will receive rewards."))),(0,n.kt)("p",null,"To read more please see our ",(0,n.kt)("a",{parentName:"p",href:"https://weatherxm.com/whitepaper"},"whitepaper")),(0,n.kt)("p",null,"We will split the process into 5 distinct steps in an attempt to make everything as clear as possible. "),(0,n.kt)("p",null,"a. The following variables have known values at the start of each day:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"daily_emission"),": the amount of tokens that are available for allocation on the given day"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"weight_per_hardware_class"),": the number denoting how important an HC is compared to all the other HC"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"pol_threshold"),": the number denoting the cutoff threshold for PoL: weather stations with ",(0,n.kt)("inlineCode",{parentName:"li"},"pol_score`` < pol_threshold")," are ",(0,n.kt)("strong",{parentName:"li"},"excluded")," from rewarding"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"qod_threshold"),": the number denoting the cutoff threshold for QoD: weather stations with ",(0,n.kt)("inlineCode",{parentName:"li"},"qod_score < qod_threshold")," are ",(0,n.kt)("strong",{parentName:"li"},"excluded")," from rewarding"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"capacity")," per cell: the maximum number of weather stations that will be rewarded in a cell - the rest are ",(0,n.kt)("strong",{parentName:"li"},"excluded")," from rewarding")),(0,n.kt)("p",null,"b. To calculate the rewardable count of devices per ",(0,n.kt)("strong",{parentName:"p"},"HC"),":"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"we exclude weather stations that are owned by users with no wallet address specified"),(0,n.kt)("li",{parentName:"ul"},"we count the weather stations with ",(0,n.kt)("strong",{parentName:"li"},"qod_score")," and ",(0,n.kt)("strong",{parentName:"li"},"pol_score")," over the respected specified thresholds, ",(0,n.kt)("inlineCode",{parentName:"li"},"qod_threshold"),", ",(0,n.kt)("inlineCode",{parentName:"li"},"pol_threshold")," The number of stations that pass this evaluation are eligible for rewards.")),(0,n.kt)("p",null,"c. To calculate the ",(0,n.kt)("strong",{parentName:"p"},"max_reward_per_hardware_class (MRPHC)"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"total_weights = sum(rewardable_count_per_hardware_class[i] * weight_per_hardware_class[i]), i = 1..n, where n = total number of HC\n")),(0,n.kt)("p",null,"For every HC:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"tokens_per_hardware_class = daily_emission * (rewardable_count_per_hardware_class * weight_per_hardware_class) / total_weights\n\nmax_reward_per_hardware_class = tokens_per_hardware_class / rewardable_count_per_hardware_class\n")),(0,n.kt)("p",null,"d. To calculate the ",(0,n.kt)("strong",{parentName:"p"},"reward_score")," and ",(0,n.kt)("strong",{parentName:"p"},"base_reward"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"reward_score = pol_score * qod_score\n\nbase_reward = reward_score * max_reward_per_hardware_class\n")),(0,n.kt)("p",null,"e. To identify overcrowded cells and decide which of the weather stations will be excluded from rewarding:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"we iterate over available cells and check whether it is overcrowded"),(0,n.kt)("li",{parentName:"ul"},"in case it is indeed overcrowded, we sort the neighboring weather stations first by ",(0,n.kt)("inlineCode",{parentName:"li"},"reward_score")," and then by seniority (",(0,n.kt)("inlineCode",{parentName:"li"},"claimed_time"),"). Only the ",(0,n.kt)("inlineCode",{parentName:"li"},"N")," first will be rewarded, where ",(0,n.kt)("inlineCode",{parentName:"li"},"N = capacity"))),(0,n.kt)("h3",{id:"2-business-boost-rewards-calculation"},"2. Business Boost rewards calculation"),(0,n.kt)("p",null,"The business boost use cases reward specific devices with a predefined amount of tokens from the Business Development Pool for a period of time. In this phase, all business boost rewards are calculated for each active business boost use case and they are assigned to the eligible devices. The business boost rewards are calculated using the following formula per active business boost use case:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"business_boost_reward = (business_boost_total_rewards / business_boost_duration) / number_of_business_boost_stations\n")),(0,n.kt)("h3",{id:"3-cumulative-rewards-calculation"},"3. Cumulative Rewards Calculation"),(0,n.kt)("p",null,"In the third phase of the rewarding mechanism, the cumulative rewards per user are calculated. The cumulative rewards are the sum of all base and business boost rewards that each user's weather station  owns."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"cumulative_rewards_per_customer = sum(base_reward[i] + business_boost_reward[i]), i = 1..n where n = total number of devices per user\n")),(0,n.kt)("h3",{id:"4-merkle-tree-creation"},"4. Merkle Tree Creation"),(0,n.kt)("p",null,"In the final phase, the cumulative rewards coupled with the users' wallet addresses are utilized to create the Merkle tree. The root hash of the Merkle tree is submitted daily in the smart contract to enable $WXM rewards withdrawal by the users."),(0,n.kt)("h3",{id:"pseudocode"},"Pseudocode"),(0,n.kt)("p",null,"To sum up all of the above in pseudocode:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// base reward\nrewardable = {\n  'Helium': {\n    count: 0,\n    weight: 0.9,\n    devices: []\n  },\n  'M5': {\n    count: 0,\n    weight: 1.1,\n    devices: []\n  }\n}\n\nfor cell in cells:\n  cell_devices = []\n  for device in cell:\n    if isEmpty(device.owner.wallet):\n      device.reward_score = 0\n      device.reward_reason = 'NO_WALLET'\n      device.base_reward = 0\n      continue\n    if qod_score < qod_threshold:\n      device.reward_score = 0\n      device.reward_reason = 'QOD_THRESHOLD'\n      device.base_reward = 0\n      continue\n    if pol_score < pol_threshold:\n      device.reward_score = 0\n      device.reward_reason = 'POL_THRESHOLD'\n      device.base_reward = 0\n      continue\n    device.reward_score = reward_algorithm(device.pol_score, device.qod_score)\n    cell_devices.push(device)\n    rewardable[device.hardware_class].count += 1\n    rewardable[device.hardware_class].push(device)\n\n  cell_devices.sort( (x, y):  \n    if x.reward_score == y.reward_score:\n      return x.claimedAt - y.claimedAt\n    return y.reward_score - x.reward_score \n  )\n\n  for (device, i) in cell_devices:\n    device.bb_reward = 0\n    if i >= cell.capacity:\n      device.reward_score = 0\n      device.reward_reason = 'MAX_CAPACITY_REACHED'\n      device.base_reward = 0\n\ntotal_weights = 0\nfor key in rewardable.keys:\n  hc = rewardable[key]\n  total_weights += hc.count * hc.weight \n\nfor key in rewardable.keys:\n  hc = rewardable[key]\n  hc.max_rewards = daily_emission * hc.weight / total_weights \n  for device in hc.devices:\n    device.base_reward = device.reward_score * hc.max_rewards\n\n// business boost\nfor bb in business_boosts:\n  for device in bb.devices:\n    device.bb_reward += bb.daily_reward\n\n// cumulative calculation\nfor user in users:\n  daily_cumulative_rewards = 0\n  for device in user.devices:\n    daily_cumulative_rewards = device.bb_reward + device.base_reward\n  if not user.active_wallet:\n    continue\n  user.wallets[user.active_wallet] = daily_cumulative_rewards\n\n// merkle tree\ntree = []\nfor user in users:\n  for wallet in wallets:\n    tree.push([wallet, user[wallet].cumulative])\n\n\n// blockchain tx\nsubmit(tree.root_hash())\n")),(0,n.kt)("h2",{id:"withdrawing-rewards"},"Withdrawing Rewards"),(0,n.kt)("p",null,"Station owners have the freedom to withdraw their rewards at their discretion, without any time restrictions or other limitations."),(0,n.kt)("p",null,"Each owner may initiate the withdrawal process by signing a transaction using the private key that corresponds to the blockchain address they have connected to their station. A user-friendly front-end that can be used in conjunction with a wallet like Metamask will be provided, but station owners can also interact programmatically with the ",(0,n.kt)("strong",{parentName:"p"},"RewardPool")," smart contract to withdraw their rewards directly."),(0,n.kt)("h2",{id:"smart-contracts-and-rewarding-mechanism"},"Smart Contracts and Rewarding Mechanism"),(0,n.kt)("p",null,"The smart contracts and wallets associated with the rewarding mechanism are the following:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"WeatherXM"),": ERC20 token"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"RewardPool"),": smart contract holding users' allocated $WXM rewards"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"RewardVault"),": smart contract holding the total amount of $WXM rewards to be allocated"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"BusinessDevelopmentPool"),": wallet holding all $WXM leftovers from daily rewards")),(0,n.kt)("p",null,"The lifecycle of rewards from the rewarding mechanism to the users' wallets:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"Reward Mechanism")," calculates all rewards and allocates them to ",(0,n.kt)("strong",{parentName:"li"},"RewardPool")),(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"RewardPool")," holds all allocated rewards"),(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"RewardVault")," funds the ",(0,n.kt)("strong",{parentName:"li"},"RewardPool")," with the daily emission of $WXM"),(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"Business Development Pool")," funds daily the ",(0,n.kt)("strong",{parentName:"li"},"RewardPool")," with the business boost of $WXM"),(0,n.kt)("li",{parentName:"ul"},"The station owners withdraw their rewards programmatically or through the WeatherXM Platform by interacting with the ",(0,n.kt)("strong",{parentName:"li"},"RewardPool"))))}h.isMDXComponent=!0}}]);